# 基本概念

fleximg を理解するための基本概念を説明します。

## ノードベース画像処理とは

**ノードベース画像処理**とは、画像処理の各ステップを「ノード」と呼ばれる部品として表現し、それらをつなぎ合わせてパイプラインを構築する手法です。

### 従来の方式との比較

```
【従来のコード】
image = loadImage("photo.jpg");
image = brightness(image, 0.2);
image = blur(image, 5);
image = grayscale(image);
saveImage(image, "output.jpg");

【ノードベース】
SourceNode → BrightnessNode → HBlurNode → VBlurNode → GrayscaleNode → SinkNode
```

### ノードベースの利点

1. **視覚的な理解**: 処理の流れが図として見える
2. **再利用性**: 同じノードを複数の場所で使い回せる
3. **分岐と合流**: 1つの画像を複数に分けたり、複数を1つに合成できる
4. **遅延評価**: 必要な部分だけを計算できる

```
例: 1つのソースから2種類の出力を作成

SourceNode ─┬─→ GrayscaleNode → SinkNode(グレー版)
            │
            └─→ BlurNode → SinkNode(ぼかし版)
```

---

## グラフエディタの基本

fleximg の WebUI はノードグラフエディタです。

### 用語

| 用語 | 意味 |
|------|------|
| ノード | 処理の単位（四角形のボックス） |
| ポート | ノードの入出力点（ノードの端にある丸） |
| ワイヤー | ポート間を結ぶ線（データの流れ） |
| パイプライン | ノードとワイヤーで構成された処理全体 |

### pivot の概念

fleximg では **pivot** を「ワールド原点 (0,0) に対応する点」として統一的に扱います。

| ノード | pivot の意味 |
|--------|-------------|
| SourceNode | 画像内のこの点がワールド原点に対応 |
| RendererNode | スクリーン上のこの点がワールド原点に対応 |
| SinkNode | バッファ内のこの点が回転中心 |

回転を適用すると、ワールド原点を軸として回転が行われます。
つまり、SourceNode の pivot と RendererNode の pivot は
「ワールド原点で出会う」関係にあります。

```
SourceNode          RendererNode         結果
pivot(16,16)   →    pivot(50,50)    →   画像位置
    ↓                    ↓
ソース内の           スクリーン上の
この点が...          この位置に表示

    └── ワールド原点 (0,0) で一致 ──┘
```

**pivot の設定例:**
```cpp
SourceNode src(imageView);
src.setPivot(width/2, height/2);  // 画像中央がワールド原点に対応

RendererNode renderer;
renderer.setVirtualScreen(640, 480);
renderer.setPivot(320, 240);  // スクリーン中央にワールド原点を表示
// または
renderer.setPivotCenter();    // 同じ効果
```

### RenderRequest/Response の origin

`RenderRequest` と `RenderResponse` の `origin` は、バッファ左上のワールド座標を表します。
これは pivot とは異なり、スキャンライン処理で各行のバッファ位置を特定するために使用されます。

### pivot と tx/ty の違い

アフィン変換において、pivot と tx/ty は異なる役割を持ちます。

| パラメータ | 回転時の効果 | 回転なしの効果 |
|-----------|-------------|---------------|
| **pivot** | 回転中心が変わる（形が変わる） | 効果なし |
| **tx/ty** | 回転後に平行移動（形は同じ） | 平行移動 |

**例: 時計の針**

```
pivot = 針の根元
tx, ty = 時計盤上での位置

回転角度を変えると:
- pivot を中心に針が回転
- tx, ty で時計盤の中心に配置
```

### 基本操作

1. **ノード追加**: キャンバス右クリック → メニューから選択
2. **接続**: 出力ポートから入力ポートへドラッグ
3. **パラメータ調整**: ノードをクリック → サイドパネルで編集
4. **実行**: Renderer ノードが自動的にパイプラインを実行

### データの流れ

```
上流（ソース側）                下流（出力側）
─────────────────              ─────────────────
画像データを提供    →  処理  →   結果を受け取る
SourceNode                     SinkNode
```

---

## タイル分割処理

### なぜタイル分割が必要か

大きな画像（例: 4K = 3840x2160ピクセル）を一度に処理すると、大量のメモリが必要です。

```
4K画像のメモリ使用量:
  3840 × 2160 × 4バイト(RGBA) = 約33MB

パイプラインに5ノードあると:
  33MB × 5 = 約165MB（中間バッファ含む）
```

組込み環境（Arduino、ESP32など）では、このようなメモリは確保できません。

### タイル分割の仕組み

画像を小さなタイル（例: 64x1ピクセル）に分割し、タイルごとに処理します。

```
【一括処理】                    【タイル分割処理】
┌─────────────────┐            ┌─────────────────┐
│                 │            │ ← 64px →        │
│  全体を一度に   │            │████│            │ ← 1行ずつ
│  処理           │            │    ↓ 次の行     │
│                 │            │    ...          │
└─────────────────┘            └─────────────────┘
メモリ: 大                      メモリ: 小
```

### メモリ効率

```
タイル分割時のメモリ使用量:
  64 × 1 × 4バイト × 数行分 = 数KB程度
```

---

## スキャンライン処理

fleximg では、タイルの高さは常に1ピクセル（＝スキャンライン）です。

### スキャンラインとは

CRTモニターの走査線に由来する用語で、画像の1行（横1列のピクセル）を指します。

```
画像を1行ずつ処理:
行0: ████████████████████
行1: ████████████████████  ← 現在処理中
行2: ████████████████████
...
```

### スキャンライン処理の利点

1. **メモリ効率**: 常に1行分のバッファで処理可能
2. **DDA最適化**: アフィン変換で行単位の最適化が可能
3. **ストリーミング**: LCDへの直接出力と相性が良い

### 制約

ぼかしフィルタ（VerticalBlurNode）のように、上下のピクセルを参照する処理では、複数行のキャッシュが必要です。fleximg ではこれを内部的に管理しています。

---

## プル型とプッシュ型

fleximg のパイプラインには2つの処理方向があります。

### プル型（Pull）

**下流が上流に「データをください」と要求する方式**

```
SinkNode: 「(0,0)から(64,1)の範囲をください」
    ↑ 要求
FilterNode: 「上流さん、(0,0)から(64,1)をください」
    ↑ 要求
SourceNode: 「はい、どうぞ」
    ↓ データ
FilterNode: 処理して返す
    ↓ データ
SinkNode: 受け取る
```

**特徴**: 必要な部分だけを計算（遅延評価）

### プッシュ型（Push）

**上流が下流に「データを受け取って」と送る方式**

```
SourceNode: 「行0のデータです」
    ↓ データ
FilterNode: 処理して次へ
    ↓ データ
SinkNode: 受け取る
```

**特徴**: ストリーミング処理に適する

### RendererNode の役割

RendererNode は **プル型とプッシュ型の境界** です。

```
【上流】プル型           【下流】プッシュ型
────────────────        ────────────────
SourceNode              SinkNode
    ↑ pull                  ↓ push
AffineNode      →→→   RendererNode   →→→
    ↑ pull              (発火点)
FilterNode
```

RendererNode が実行されると:
1. 上流に対してプル型でデータを要求
2. 取得したデータを下流にプッシュ型で配信

---

## pivot と座標系

### なぜ pivot が必要か

画像の「どこを中心に」回転・拡大するかを指定するためです。

```
【左上が pivot】              【中央が pivot】
回転すると...                 回転すると...
┌───┐      ╱╲               ┌───┐      ╱╲
│ ● │  →  ╱  ╲              │   │  →  ╲  ╱
└───┘    ╱    ╲             │ ● │      ╲╱
         ↑左上を軸に回転     └───┘      ↑中央を軸に回転
```

### pivot の位置

`pivot` はバッファ内での回転中心の位置を表します。

```
100x100の画像で:
  pivot = (0, 0)   → 左上が回転中心
  pivot = (50, 50) → 中央が回転中心
  pivot = (100, 100) → 右下が回転中心
```

### pivot 一致ルール

**SourceNode と SinkNode の pivot がワールド原点で一致するように配置されます。**

詳細は [DESIGN_RENDERER_NODE.md](DESIGN_RENDERER_NODE.md) を参照してください。

---

## 関連ドキュメント

- [QUICKSTART.md](QUICKSTART.md) - すぐに試したい方へ
- [ARCHITECTURE.md](ARCHITECTURE.md) - 技術的な詳細
- [DESIGN_RENDERER_NODE.md](DESIGN_RENDERER_NODE.md) - 座標系の詳細な例
